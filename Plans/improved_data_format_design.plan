# Improved Data Format Design for Local-Transcribe

## Executive Summary

This document outlines a comprehensive design for an improved data format in the local-transcribe project that preserves segment information from transcriber plugins. The current implementation lacks explicit segment structures, causing valuable acoustic and semantic grouping information to be lost during transcription.

## Current State Analysis

### Existing Data Structures

1. **WordSegment** (lines 16-22 in [`plugin_interfaces.py`](local_transcribe/framework/plugin_interfaces.py:16))
   ```python
   @dataclass
   class WordSegment:
       text: str
       start: float
       end: float
       speaker: Optional[str] = None
   ```

2. **Turn** (lines 25-31 in [`plugin_interfaces.py`](local_transcribe/framework/plugin_interfaces.py:25))
   ```python
   @dataclass
   class Turn:
       speaker: str
       start: float
       end: float
       text: str
   ```

### Current Limitations

1. **Missing Segment Level**: No explicit `Segment` data structure exists between `Turn` and `WordSegment`
2. **Lost Acoustic Information**: Transcribers like MLX Whisper produce segments internally but convert directly to `WordSegment`s
3. **Arbitrary Turn Boundaries**: Turn builders use arbitrary thresholds (0.8s gaps, 120 characters, 500 words) rather than natural content boundaries
4. **Incomplete Hierarchy**: Current hierarchy is `Turn → WordSegment` (missing Segment level)

### Evidence from Codebase

1. **MLX Whisper Implementation** ([`mlx_whisper.py:129-136`](local_transcribe/providers/transcribers/mlx_whisper.py:129)):
   ```python
   for segment in result.get("segments", []):
       for word_info in segment.get("words", []):
           word_segments.append(WordSegment(
               text=word_info["word"].strip(),
               start=word_info["start"],
               end=word_info["end"],
               speaker=role
           ))
   ```
   The original segment information is lost during conversion.

2. **Turn Builder Thresholds** ([`single_speaker_gap_based_turn_builder.py:38-39`](local_transcribe/providers/turn_builders/single_speaker_gap_based_turn_builder.py:38)):
   ```python
   max_gap_s = kwargs.get('max_gap_s', 0.8)
   max_chars = kwargs.get('max_chars', 120)
   ```

## Proposed Design

### 1. New Segment Data Structure

```python
@dataclass
class Segment:
    """Represents a group of related words with acoustic/semantic coherence."""
    
    # Core timing and content
    start: float
    end: float
    text: str
    
    # Speaker information
    speaker: Optional[str] = None
    
    # Segment metadata
    confidence: Optional[float] = None  # Overall segment confidence score
    segment_type: Optional[str] = None  # "acoustic", "semantic", "mixed"
    
    # Word-level data (optional for backward compatibility)
    words: Optional[List[WordSegment]] = None
    
    # Additional metadata
    language: Optional[str] = None
    prosody_features: Optional[Dict[str, Any]] = None
    
    @property
    def duration(self) -> float:
        """Calculate segment duration."""
        return self.end - self.start
    
    @property
    def word_count(self) -> int:
        """Get word count from words list or text."""
        if self.words:
            return len(self.words)
        return len(self.text.split()) if self.text else 0
```

### 2. Improved Data Hierarchy

The new hierarchy will be: **Turn → Segment → WordSegment**

```mermaid
graph TD
    Turn --> Segment1
    Turn --> Segment2
    Turn --> Segment3
    Segment1 --> WordSegment1
    Segment1 --> WordSegment2
    Segment1 --> WordSegment3
    Segment2 --> WordSegment4
    Segment2 --> WordSegment5
    Segment3 --> WordSegment6
    Segment3 --> WordSegment7
    Segment3 --> WordSegment8
```

### 3. Enhanced Turn Structure

```python
@dataclass
class Turn:
    """Represents a conversation turn with speaker, timing, and segments."""
    
    # Core fields (maintain backward compatibility)
    speaker: str
    start: float
    end: float
    text: str
    
    # New segment-based structure
    segments: Optional[List[Segment]] = None
    
    # Turn metadata
    confidence: Optional[float] = None
    language: Optional[str] = None
    
    @property
    def duration(self) -> float:
        """Calculate turn duration."""
        return self.end - self.start
    
    @property
    def word_count(self) -> int:
        """Get total word count from segments or text."""
        if self.segments:
            return sum(segment.word_count for segment in self.segments)
        return len(self.text.split()) if self.text else 0
    
    def ensure_text_consistency(self) -> None:
        """Ensure text field matches concatenated segment texts."""
        if self.segments and not self.text:
            self.text = " ".join(segment.text for segment in self.segments).strip()
```

### 4. Transcriber Interface Enhancements

#### New Property for Segment Support

```python
class TranscriberProvider(ABC):
    # ... existing properties ...
    
    @property
    @abstractmethod
    def has_builtin_segments(self) -> bool:
        """Return True if this transcriber provides segment-level information."""
        pass
    
    @abstractmethod
    def transcribe_with_segments(
        self,
        audio_path: str,
        role: Optional[str] = None,
        **kwargs
    ) -> List[Segment]:
        """
        Transcribe audio file and return segment-level information.
        
        Args:
            audio_path: Path to the audio file
            role: Optional speaker role
            **kwargs: Provider-specific configuration options
            
        Returns:
            List of Segment objects with timing, text, and metadata
        """
        pass
```

#### Enhanced Alignment Interface

```python
class AlignerProvider(ABC):
    # ... existing methods ...
    
    @abstractmethod
    def align_segments(
        self,
        audio_path: str,
        segments: List[Segment],
        **kwargs
    ) -> List[Segment]:
        """
        Align segment text to audio and return enhanced segments with word-level timing.
        
        Args:
            audio_path: Path to the audio file
            segments: Segment objects to align
            **kwargs: Provider-specific configuration options
            
        Returns:
            List of Segment objects with enhanced word-level timing
        """
        pass
```

### 5. Turn Builder Enhancements

#### Segment-Aware Turn Building

```python
class TurnBuilderProvider(ABC):
    # ... existing methods ...
    
    @abstractmethod
    def build_turns_from_segments(
        self,
        segments: List[Segment],
        **kwargs
    ) -> List[Turn]:
        """
        Build conversation turns from segments with speakers.
        
        Args:
            segments: Segment objects with speaker assignments
            **kwargs: Provider-specific configuration options
            
        Returns:
            List of Turn objects grouped by speaker and timing
        """
        pass
    
    def build_turns(
        self,
        words: List[WordSegment],
        **kwargs
    ) -> List[Turn]:
        """
        Enhanced turn building that can work with both words and segments.
        
        Args:
            words: Word segments with speaker assignments
            **kwargs: Provider-specific configuration options
            
        Returns:
            List of Turn objects grouped by speaker and timing
        """
        # Check if segments are available in kwargs
        segments = kwargs.get('segments')
        if segments:
            return self.build_turns_from_segments(segments, **kwargs)
        
        # Fall back to word-based approach for backward compatibility
        return self._build_turns_from_words(words, **kwargs)
```
